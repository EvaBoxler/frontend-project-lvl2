"use strict";
exports.__esModule = true;
exports.create_snapshots = void 0;
var tslib_1 = require("tslib");
var definitions_1 = require("../definitions");
var create_message_1 = require("./create-message");
var get_diagnostic_message_1 = require("./get-diagnostic-message");
var get_display_line_1 = require("./get-display-line");
var get_trigger_line_1 = require("./get-trigger-line");
var traverse_node_1 = require("./traverse-node");
var create_snapshots = function (filename, triggers, normalized_config) {
    var ts = normalized_config.typescript, compiler_options = normalized_config.compiler_options, file_names = normalized_config.file_names, enclosing_declaration = normalized_config.enclosing_declaration, type_format_flags = normalized_config.type_format_flags;
    var program = ts.createProgram(tslib_1.__spreadArray([filename], file_names, true), compiler_options);
    var source_file = program.getSourceFile(filename);
    var body_line_map = new Map();
    triggers.forEach(function (trigger) {
        if (trigger.header.flags & definitions_1.TriggerHeaderFlags.Assertion) {
            var body_line = (0, get_trigger_line_1.get_trigger_body_line)(trigger.header.line);
            body_line_map.set(body_line, trigger);
        }
    });
    var unmatched_diagnostics = [];
    var snapshots = [];
    make_ts_expect_error_diagnostics_available(source_file, ts);
    var diagnostics = ts.getPreEmitDiagnostics(program, source_file);
    for (var _i = 0, diagnostics_1 = diagnostics; _i < diagnostics_1.length; _i++) {
        var diagnostic = diagnostics_1[_i];
        var position = diagnostic.start;
        var line = source_file.getLineAndCharacterOfPosition(position).line;
        if (!body_line_map.has(line)) {
            unmatched_diagnostics.push({
                line: line,
                message: (0, get_diagnostic_message_1.get_diagnostic_message)(diagnostic)
            });
            continue;
        }
        snapshots.push({
            line: line,
            diagnostic: ts.flattenDiagnosticMessageText(diagnostic.messageText, '\n')
        });
        body_line_map["delete"](line);
    }
    if (unmatched_diagnostics.length !== 0) {
        throw new Error((0, create_message_1.create_message)('Unmatched diagnostic(s) detected:', unmatched_diagnostics.map(function (_a) {
            var line = _a.line, message = _a.message;
            return "".concat(source_file.fileName, ":").concat((0, get_display_line_1.get_display_line)(line), " ").concat(message);
        })));
    }
    if (body_line_map.size === 0) {
        return snapshots;
    }
    var checker = program.getTypeChecker();
    (0, traverse_node_1.traverse_node)(source_file, function (node) {
        var position = node.getStart();
        var line = source_file.getLineAndCharacterOfPosition(position).line;
        if (!body_line_map.has(line)) {
            return;
        }
        var target_node = node.getChildAt(0);
        var type = checker.getTypeAtLocation(target_node);
        snapshots.push({
            line: line,
            inference: checker.typeToString(type, 
            // istanbul ignore next
            enclosing_declaration ? node : undefined, type_format_flags)
        });
        body_line_map["delete"](line);
    }, ts);
    return snapshots;
};
exports.create_snapshots = create_snapshots;
// ref: https://github.com/microsoft/TypeScript/pull/36014
function make_ts_expect_error_diagnostics_available(source_file, ts) {
    var comment_directives = 
    // @ts-expect-error: internal api
    source_file.commentDirectives;
    if (!Array.isArray(comment_directives)) {
        return;
    }
    for (var i = comment_directives.length - 1; i >= 0; i--) {
        var comment_directive = comment_directives[i];
        // istanbul ignore else
        // @ts-expect-error: internal api
        if (comment_directive.type === ts.CommentDirectiveType.ExpectError) {
            comment_directives.splice(i, 1);
        }
    }
}
