"use strict";
exports.__esModule = true;
exports.create_assertion_expression = exports.snapshot_assertion_message = void 0;
var definitions_1 = require("../definitions");
exports.snapshot_assertion_message = '(type) should match snapshot';
var create_assertion_expression = function (trigger, options) {
    var expressions = [];
    var header = trigger.header, body = trigger.body, footer = trigger.footer;
    push_type_show_if_available();
    push_type_pass_if_available();
    push_type_fail_if_available();
    push_type_snap_if_available();
    push_type_not_any_if_available();
    push_value_show_if_available();
    push_value_equal_if_available();
    push_value_error_if_available();
    push_value_no_error_if_available();
    return expressions.join(';');
    function push_type_show_if_available() {
        if (options.test_type && header.flags & definitions_1.TriggerHeaderFlags[':show']) {
            expressions.push(create_wrapper('(type) should show report', "console.log(".concat(options.get_type_report_expression, ")")));
        }
    }
    function push_type_pass_if_available() {
        if (options.test_type && header.flags & definitions_1.TriggerHeaderFlags[':pass']) {
            expressions.push(create_wrapper('(type) should not throw error', "expect(function () { ".concat(options.get_type_inference_or_throw_diagnostic_expression, " }).not.toThrowError()")));
        }
    }
    function push_type_fail_if_available() {
        if (options.test_type && header.flags & definitions_1.TriggerHeaderFlags[':fail']) {
            expressions.push(create_wrapper('(type) should throw error', "expect(function () { ".concat(options.get_type_inference_or_throw_diagnostic_expression, " }).toThrowError()")));
        }
    }
    function push_type_snap_if_available() {
        if (options.test_type && header.flags & definitions_1.TriggerHeaderFlags[':snap']) {
            expressions.push(create_wrapper(exports.snapshot_assertion_message, "expect(".concat(options.get_type_inference_or_diagnostic_expression, ").toMatchSnapshot()")));
        }
    }
    function push_type_not_any_if_available() {
        if (options.test_type && header.flags & definitions_1.TriggerHeaderFlags[':not-any']) {
            expressions.push(create_wrapper('(type) should not be any', "expect(".concat(options.get_type_inference_or_diagnostic_expression, ").not.toBe(\"any\")")));
        }
    }
    function push_value_equal_if_available() {
        if (options.test_value &&
            footer !== undefined &&
            footer.flag === undefined) {
            expressions.push(create_wrapper("(value) should equal to ".concat(footer.expected), "expect(".concat(body.experssion, ").toEqual(").concat(footer.expected, ")")));
        }
    }
    function push_value_error_if_available() {
        if (options.test_value &&
            footer !== undefined &&
            footer.flag === definitions_1.TriggerFooterFlag.Error) {
            expressions.push(create_wrapper('(value) should throw error', "expect(function () { ".concat(body.experssion, " }).toThrowError()")));
        }
    }
    function push_value_no_error_if_available() {
        if (options.test_value &&
            footer !== undefined &&
            footer.flag === definitions_1.TriggerFooterFlag.NoError) {
            expressions.push(create_wrapper('(value) should not throw error', "expect(function () { ".concat(body.experssion, " }).not.toThrowError()")));
        }
    }
    function push_value_show_if_available() {
        if (options.test_value &&
            footer !== undefined &&
            footer.flag === definitions_1.TriggerFooterFlag.Show) {
            expressions.push(create_wrapper('(value) should show report', "console.log(".concat(options.get_value_report_expression, ")")));
        }
    }
    function create_wrapper(title, expression) {
        var description = JSON.stringify(title);
        var method = trigger.header.method;
        return "".concat(method, "(").concat(description, ", function () { ").concat(expression, " })");
    }
};
exports.create_assertion_expression = create_assertion_expression;
