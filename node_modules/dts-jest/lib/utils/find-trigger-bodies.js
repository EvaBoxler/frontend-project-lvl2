"use strict";
exports.__esModule = true;
exports.find_trigger_bodies = void 0;
var create_message_1 = require("./create-message");
var get_display_line_1 = require("./get-display-line");
var get_node_one_line_text_1 = require("./get-node-one-line-text");
var get_trigger_groups_1 = require("./get-trigger-groups");
var get_trigger_line_1 = require("./get-trigger-line");
var traverse_node_1 = require("./traverse-node");
var find_trigger_bodies = function (source_file, headers, ts) {
    var bodies = [];
    var header_map = new Map();
    headers.forEach(function (header) { return header_map.set(header.line, header); });
    var groups = (0, get_trigger_groups_1.get_trigger_groups)(headers);
    var invalid_groups = [];
    (0, traverse_node_1.traverse_node)(source_file, function (node) {
        var start = node.getStart();
        var end = node.getEnd();
        var body_line = source_file.getLineAndCharacterOfPosition(start).line;
        var body_end_line = source_file.getLineAndCharacterOfPosition(end).line;
        // check if group position is valid (top-level comment)
        if (groups.length !== 0) {
            var first_group = groups[0];
            if (first_group.line < body_line) {
                // checked
                groups.shift();
            }
            else if (
            // group is not at the top-level (surrounded by node)
            first_group.line >= body_line &&
                first_group.line <= body_end_line) {
                invalid_groups.push(groups.shift());
            }
        }
        var header_line = (0, get_trigger_line_1.get_trigger_header_line)(body_line);
        if (node.kind <= ts.SyntaxKind.LastTriviaToken ||
            !header_map.has(header_line)) {
            return;
        }
        header_map["delete"](header_line);
        bodies.push({
            start: start,
            end: end,
            experssion: (0, get_node_one_line_text_1.get_node_one_line_text)(node, source_file, ts),
            text: get_dedented_expression_text(node, source_file)
                // remove trailing semicolons and spaces
                .replace(/\s*;*\s*$/, '')
        });
    }, ts);
    // unattachable_lines
    if (header_map.size !== 0) {
        var unattachable_line_infos_1 = [];
        header_map.forEach(function (header, line) {
            var _a = header.description, description = _a === void 0 ? '' : _a;
            unattachable_line_infos_1.push("".concat(source_file.fileName, ":").concat((0, get_display_line_1.get_display_line)(line), " ").concat(description));
        });
        throw new Error((0, create_message_1.create_message)('Unattachable trigger(s) detected:', unattachable_line_infos_1));
    }
    if (invalid_groups.length !== 0) {
        throw new Error((0, create_message_1.create_message)('Invalid trigger-group(s) detected:', invalid_groups.map(function (_a) {
            var line = _a.line, _b = _a.description, description = _b === void 0 ? '' : _b;
            return "".concat(source_file.fileName, ":").concat((0, get_display_line_1.get_display_line)(line), " ").concat(description);
        })));
    }
    return bodies;
};
exports.find_trigger_bodies = find_trigger_bodies;
function get_dedented_expression_text(node, source_file) {
    var start = node.getStart();
    var character = source_file.getLineAndCharacterOfPosition(start).character;
    return (node
        .getText(source_file)
        // dedent
        .replace(/^ */gm, function (spaces) {
        return ' '.repeat(Math.max(0, spaces.length - character));
    }));
}
