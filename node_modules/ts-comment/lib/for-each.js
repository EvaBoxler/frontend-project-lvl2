"use strict";
exports.__esModule = true;
var _ts = require("typescript");
/**
 * iterate every comment, return `false` to stop iteration
 */
function for_each(source, callback, ts) {
    if (ts === void 0) { ts = _ts; }
    var source_file = typeof source === 'string'
        ? ts.createSourceFile('', source, ts.ScriptTarget.Latest, false)
        : source;
    var source_text = source_file.getFullText();
    var scanner = ts.createScanner(ts.ScriptTarget.Latest, false, ts.LanguageVariant.Standard, source_text);
    var token = scanner.scan();
    while (token !== ts.SyntaxKind.EndOfFileToken) {
        var start = scanner.getTokenPos();
        var end = scanner.getTextPos();
        switch (token) {
            case ts.SyntaxKind.SingleLineCommentTrivia:
            case ts.SyntaxKind.MultiLineCommentTrivia: {
                var comment = scanner.getTokenText();
                if (callback(comment, scanner, source_file) === false) {
                    return;
                }
                break;
            }
            case ts.SyntaxKind.CloseBraceToken: {
                var container = get_node_container(source_file, start, end, ts);
                if (container !== undefined &&
                    (container.kind === ts.SyntaxKind.TemplateMiddle ||
                        container.kind === ts.SyntaxKind.TemplateTail)) {
                    token = scanner.reScanTemplateToken();
                    continue;
                }
                break;
            }
            case ts.SyntaxKind.SlashToken:
            case ts.SyntaxKind.SlashEqualsToken: {
                var container = get_node_container(source_file, start, end, ts);
                if (container !== undefined &&
                    container.kind === ts.SyntaxKind.RegularExpressionLiteral) {
                    token = scanner.reScanSlashToken();
                    continue;
                }
                break;
            }
            default:
                // do nothing
                break;
        }
        token = scanner.scan();
    }
}
exports.for_each = for_each;
function get_node_container(source_file, start, end, ts) {
    var container;
    find_container(source_file, start, end, function (target_container) {
        container = target_container;
    }, ts);
    return container;
}
function find_container(node, start, end, callback, ts) {
    var node_start = node.pos;
    var node_end = node.end;
    if (start < node_start || end > node_end) {
        return;
    }
    var is_token = node.kind >= ts.SyntaxKind.FirstToken &&
        node.kind <= ts.SyntaxKind.LastToken;
    if (is_token) {
        callback(node);
        return;
    }
    ts.forEachChild(node, function (child_node) {
        return find_container(child_node, start, end, callback, ts);
    });
}
